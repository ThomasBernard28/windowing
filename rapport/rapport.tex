\documentclass{article}
\usepackage{svg}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\graphicspath{images/}

\usepackage{blindtext}
\usepackage{listings}
\usepackage{color}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{background}{rgb}{0.95,0.95,0.96}

\lstset{frame=tb,
  backgroundcolor=\color{background},
  numbers=left,
  numbersep=5pt,
  captionpos=b,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\usepackage{subfiles} % Best loaded last in the preamble

\title{Rapport: Exercice préliminaire}
\author{ }
\date{ }

\begin{document}
\begin{titlepage}
    \begin{center}
        
        {\Large Université de Mons}\\[1ex]
        {\Large Faculté des sciences}\\[1ex]
        {\Large Département d'Informatique}\\[2.5cm]
        
        \newcommand{\HRule}{\rule{\linewidth}{0.3mm}}
        % Title
        \HRule \\[0.3cm]
        { \LARGE \bfseries Stuctures de données II \\[0.3cm]}
        { \LARGE \bfseries Rapport de l'exercice préléminaire \\[0.1cm]} % Commenter si pas besoin
        \HRule \\[1.5cm]
        
        % Author and supervisor
        \begin{minipage}[t]{0.45\textwidth}
            \begin{flushleft} \large
                \emph{Professeur:}\\
                Véronique \textsc{Bruyère}\\
                \emph{Assistant:}\\
                Pierre \textsc{Hauweele}\\
            \end{flushleft}
        \end{minipage}
        \begin{minipage}[t]{0.45\textwidth}
            \begin{flushright} \large
                \emph{Auteurs:} \\
                Theo \textsc{Godin} \\
                Thomas \textsc{Bernard} 
            \end{flushright}
        \end{minipage}\\[2ex]
        
        \vfill
        
        % Bottom of the page
        \begin{center}
            \begin{tabular}[t]{c c c}
                \includegraphics[height=1.5cm]{images/logoumons.jpg} &
                \hspace{0.3cm} &
                \includegraphics[height=1.5cm]{images/logofs.jpg}:
            \end{tabular}
        \end{center}~\\
        
        {\large Année académique 2022-2023}
        
    \end{center}
\end{titlepage}

\tableofcontents

\newpage

\section{Question 1}
    \paragraph{Si on ne considère que les coordonnées en x, voyez-vous que celles-ci sont organisées selon
    une file à priorité ? Où est la coordonnée minimum (maximum) ? Cette file à priorité est-elle
    un tas ? Justifiez.}
    En effet, on voit qu'il s'agit d'une file à priorité sur les coordonnées x. On va toujours prendre le point possédant la coordonnée x minimum
    afin de le placer dans le noeud racine et ce pour chaque noeud racine de chaque sous arbre. Ce qui fait que chaque racine de chaque sous arbre est un x minimal du
    jeux de points restants pour le sous arbre étudié. Donc, chacun des fils a bien une coordonée x inférieure ou égale à celle de son père.\\
    En revanche, il ne s'agit pas d'un tas. En effet, les couches ne sont pas remplies de droite à gauche. De plus, la condition de répartition établie
    sur la médiane des y impose qu'il y ait autant de noeuds dans les sous arbres gauche et droit de la racine.\\ En conclusion, aucune condition
    n'impose de remplir la dernière couche complètement de droite à gauche si il n'y a pas assez de noeuds pour le faire. On ne peut donc pas avoir de tas.\\
    La coordonnée x minimum se trouve donc dans la racine de l'arbre et la 
    coordonnée x maximum se trouve dans une des feuilles.

\section{Question 2}
    \paragraph{Si on ne considère que les coordonnées en y, voyez-vous que celles-ci sont organisées selon
    un arbre binaire de recherche ? Où est la coordonnée minimum (maximum) ? Justifiez.}
    On voit qu'il s'agit d'un arbre binaire de recherche. Tout d'abord, les conditions pour avoir un ABR sont que pour tout noeud n, son fils gauche $f_g$ est 
    tel que $n.data > f_g.data$ et son fils droit $f_d$ est tel que $n.data < f_d.data$. \\
    Ici la "data" qui est utilisée pour comparer chaque noeud avec ses fils avant une insertion est $y_{mid}$ la médiane des coordonnées y des points
    présents dans l'ensemble actuellement considéré. On retrouvera donc dans le sous arbre gauche de la racine l'ensemble des points dont les coordonnées
    y sont strictements inférieures à la médiane $y_{mid}$. Par conséquent la médiane des coordonnées y des points du sous arbre gauche qui servira
    de "data" pour le fils gauche de la racine sera également strictement inférieure à la médiane $y_{mid}$. Pour le sous arbre droit il s'agit du même raisonnement
    mais en partant du fait que les coordonnées y des points du sous arbre droit seront strictement supérieures à la médiane $y_{mid}$, i.e pour la médiane des coordonnées
    y de ces points. \\
    La coordonnée y minimum se trouve donc dans la feuille la plus à gauche de l'ABR puisqu'elle est strictement inférieure à toutes les médianes elle-même inférieures
    à celle de la racine. Et la coordonnée maximum se trouvera dans la feuille la plus à droite de l'ABR comme elle aura été strictement suppérieure à toutes
    les médianes elles-même supérieures à celle de la racine.

\newpage
\section{Question 3}
    \paragraph{De quelle façon est équilibré un arbre de recherche à priorité ?}
    Le fait que les noeuds soient répartis dans les sous-arbres droit et gauche de la racine à l'aide d'une médiane assure par la définition de
    la médiane qu'il y aura autant de noeuds possédant une coordonnées $y < y_{mid}$ que de noeuds possédant une coordonnée $y > y_{mid}$.
    Ce principe est respecté de manière récursive pour chaque noeud de chaque sous arbre. On peut donc voir l'équilibre de cette structure comme le fait
    qu'il y ait autant de noeuds à droite qu'à gauche de chaque racine de chaque sous arbre.

\section{Question 4}
    \paragraph{La construction d’un arbre de recherche à priorité peut se faire en $O(n \log_2 n)$ si n est le
        nombre de points de $R^2$ contenus dans l’arbre. Expliquez comment on peut y parvenir et
    comment le prouver. Il faut sans doute utiliser une autre structure de données qui permet
    de calculer efficacement la médiane.}
    L'algorithme de construction de l'arbre de recherche à priorité peut être trouvé sur internet (Wikipédia). A l'aide du master theorem
    vu au cours de SDD1 on peut prouver que cet algorithme est en $O(n \log n)$. On peut voir ci-dessous l'algorithme de création d'un arbre 
    de recherche à priorité avec le calcul de complexité ainsi que la source du code : 
    %TODO : faire la preuve de complexité sur la tablette afin d'insérer l'image ici.
    \medskip
    \begin{lstlisting}
tree construct_tree(data) {
    if length(data) > 1 {
            
        node_point = find_point_with_minimum_priority(data) // Select the point with the lowest priority
              
        reduced_data = remove_point_from_data(data, node_point)
        node_key = calculate_median(reduced_data) // calculate median, excluding the selected point
              
        // Divide the points 
        left_data = []
        right_data = []    
             
        for (point in reduced_data) {
            if point.key <= node_key
                left_data.append(point)
            else
                right_data.append(point)
        }
          
        left_subtree = construct_tree(left_data)
        right_subtree = construct_tree(right_data)
          
        return node // Node containing the node_key, node_point and the left and right subtrees
          
    } else if length(data) == 1 {
        return leaf node // Leaf node containing the single remaining data point
    } else if length(data) == 0 {
        return null // This node is empty
    }
}

    \end{lstlisting}
\medskip
    \textbf{Source : } \url{https://en.wikipedia.org/wiki/Priority_search_tree}\\

    \textbf{Calcul de complexité : }
    Les lignes 2,4,6,10,11,23,25,26,27 et 28 sont en O(1). \\
    \begin{enumerate}
        \item\textbf{find\_point\_with\_minimmum\_priority(data) : } Il s'agit de trouver la coordonnée minimum en x on va donc itérer au maximum
        n fois en O(1) on a donc du O(n).
        \item\textbf{calculate\_median(reduced\_data) : } Si l'on a trié les données selon les y au sein d'une liste au préalable on peut calculer la 
        médiane de reduced\_data en O(1) car elle se trouver à l'indice : $\frac{len(reduced\_data)}{2}$
        \item\textbf{boucle for : } Toutes les instructions au sein de la boucle for sont en O(1) on effectue au maximum n itérations dans la boucle
        ce qui veut dire que celle-ci est en O(n).
        \item\textbf{Appels récursifs des lignes 20 et 21 :} On va appliquer le Master theorem afin de calculer la complexité des appels récursifs.
        La formule est la suivante : $T(n) = aT(\frac{n}{b}) + O(n^d)$ où : 
            \begin{enumerate}
                \item \textbf{n : } taille du problème = n
                \item \textbf{a : } nombre de sous-problèmes dans lequel l'appel est divisé. Dans notre cas $a = 2$.
                \item \textbf{$\frac{n}{b}$ : } La taille de chaque sous problème. Dans notre cas c'est $\frac{n-1}{2}$
                \item \textbf{$O(n^d)$ : } Correspond au coût de gestion du reste de la fonction ici en O(n) donc $d=1$
            \end{enumerate}
        Le master Theorem dit que si $d = \log_b(a)$ alors on a $T(n) = O(n^d \log_b(n))$. On a bien que $1 = \log_2(2)$ donc
        Notre appel récursif est effectué en $O(n\log_2n)$.

    \end{enumerate}

    En conclusion si l'on additionne tout, on obtient que l'algorithme est bien en $O(n\log_2n)$

\newpage

\section{Question 5}
Ici la question implique de modifier la manière dont la fenêtre de recherche est bornée sur la coordonnée x. Rappellons que les coordonnées x sont organisées sous forme d'une file à priorité.
Ce qui implique que les fils d'un noeud ont une coordonnée x supérieure ou égale à celle de leur père. L'algorithme proposé est initialement rédigé pour des requêtes bornées par un x maximum. Il y a donc
une condition qui contrôle pour chaque noeud de chaque sous-arbre en partant de la racine si la coordonnée x est inférieure ou égale à la borne supérieure de la fenêtre de recherche. \\

    \begin{enumerate}
        \item \textbf{Fenêtre bornée par un x minimum.} Dans ce cas, on peut utiliser la définition de file à priorité à notre avantage. En effet, on change la condition de contrôle de la coordonnée x.
        A présent au lieu de contrôler si la coordonée x est inférieure ou égale à la borne supérieure de la fenêtre de recherche, on contrôle si la coordonnée x est supérieure ou égale à la borne inférieure de la fenêtre de recherche.
        Si c'est le cas, alors on peut accepter l'entièreté du sous arbres car les fils de la racine de ce sous arbres auront une coordonnée supérieure ou égale à celle de leur père.
        \item \textbf{Fenêtre bornée par un x minimum et un x maximum.} Dans ce cas on associe les deux conditions. Il faut que pour chaque noeud du sous arbre considéré, la coordonnée x soit supérieure ou égale à la borne inférieure et
        inférieure ou égale à la borne supérieure de la fenêtre de recherche. Dans le cas où l'on rencontre un noeud dont la coordonée x est supérieure à celle de la borne supérieure on considère par la définition
        d'une file à priorité que tous ses descendants auront une coordonnée x supérieure à celle de la borne supérieure. On peut donc arrêter la recherche dans ce sous arbre.
        \item \textbf{Fenêtre non bornée sur un y minimum.} Dans le cas où la fenêtre n'est pas bornée sur un y minimum on peut établir que tous les sous abres à gauche du noeud 
        $v_{split}$ auront une coordonnée en y comprise dans l'intervalle car la coordonnée y minimale se trouve dans la feuille la plus à gauche de l'arbre.
        \item \textbf{Fenêtre non bornée sur un y maximum.} Dans le cas où la fenêtre n'est pas bornée sur un y maximum on peut établir que tous les sous arbres à droite du noeud
        $v_{split}$ auront une coordonnée en y comprise dans l'intervalle car la coordonnée y maximale se trouve dans la feuille la plus à droite de l'arbre.
    \end{enumerate}
\newpage
\section{Question 6}
    \paragraph{Les auteurs du Chapitre 10 font l’hypothèse que tous les points ont des coordonnées bien
distinctes en x et en y. Expliquez pourquoi.}
Dans l'arbre de recherche à priorité, la comparaison de noeuds se fait par rapport à la coordonée x et à la médiane $y_{mid}$. Un problème se pose lorsque 2 points devant être insérés ont une coordonée x identique et une coordonnée y se trouvant du 
même côté de la médiane $y_{mid}$ de la racine du sous arbre. En effet, imaginons deux points $(2,3)$ et $(2,4)$ et la racine du sous arbre dont la médiane est $y_{mid} = 2$ dans lequel ils doivent être insérés. Les deux noeuds doivent figurer dans
le sous arbres droit. Dès lors on va se servir de la règle de la file de priorité sur x et on va sélectionner la coordonnée x la plus petite en priorité. Or, ici, x = 2 dans les deux cas. On ne peut donc pas déterminer quel noeud sera le fils droit 
et quel noeud deviendra un potentiel fils de ce fils droit.

\section{Question 7}
    \paragraph{Une technique est présentée à la page 111. Celle-ci permet de simuler des coordonnées
distinctes pour un ensemble de points quelconques et une requête. Expliquez comment.}
La technique présentée est celle des "composite-numbers". Au lieu de définir un point par sa coordonnée x et sa coordonnée y tq $p = (p_x , p_y)$ on va le définir à l'aide
d'un composite number pour chaque coordonnée comme suit : $p = ((p_x|p_y),(p_y|p_x))$.
Dès lors, les coordonnées x et y deviennent des composite numbers et si l'on reprend l'exemple donné à la question 6 on voit qu'à présent les points seront respectivement
représentés comme suit : $((2|3), (3|2))$ et $((2|4),(4|2))$. On voit à présent que l'on peut trouver lequel de ces deux points a une coordonnée x plus petite en comparant
les deux membres du composite number. On aura bien que 2=2 mais également que 3<4. Ceci est également valable dans le cas où 2 coordonnées y sont identiques.

\section{Question 8}
    \paragraph{Dans le chapitre, la technique présentée est adaptée à des points. Quelles différences
    importantes aurait-on avec des segments de droite ? Comment peut-on adapter la technique ?}
    Un point est représenté par une coordonnée x et y comme suit : $p = (x,y)$, si on lui applique la technique des composite-numbers, il sera
    représenté comme suit : $p = ((p_x|p_y),(p_y|p_x))$. On va donc essayer d'adapter cette notation à un segment de droite. Tout d'abord, 
    on peut établir qu'un segment de droite est défini par 2 points : $p = (x,y)$ et $q=(x',y')$ qui sont ses extrémités. On peut également
    établir que dans les cas des segments de droite le problème énoncé à la question 6, n'est pas d'application car même si 2 segments avaient
    une extrémités en commun, ils ne pourraient pas avoir l'autre extrémité en commun sans être identiques, on pourrait donc se servir d'une 
    des deux extrémités afin de déterminer quel segment est le plus proche du x parent ou de la médiane parent. Dès lors, nous avions pensé
    à écrire un segment comme suit : $segment = ((x|y),(x'|y'))$ mais il s'avère que cela rendra le calcul de la médiane plus compliqué du fait
    qu'il faudra accéder aux 2 termes du composite-number. En conclusion un segment sera représenté comme suit : $segment = ((x|x'),(y|y'))$ c'est à dire,
    avec les coordonnées x de chaque extrémité comme première composante et les coordonnées y de chaque extrémité comme deuxième composante.

\end{document}
